{
  "ver": "1.0.27",
  "uuid": "2f6523c7-51f5-4edd-8a13-da00b4ad098e",
  "importer": "effect",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\nuniform vec4 cc_time;\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform float wh_ratio;\nvec2 Hash12(float t) {\n  float a = fract(sin(t * 123.45 + 678.9) * 345.124);\n  float b = fract(cos((t + a) * 243.45 + 738.9) * 512.352);\n  return vec2(a, b);\n}\nfloat Explosion(vec2 uv, float t) {\n  float m = 0.0;\n  float minBright = 0.001;\n  float maxBright = 0.002;\n  float split = 0.2;\n  float pt = fract(smoothstep(0., split, t));\n  pt = max(0., log(pt + 0.01) * 0.3 + 1.0);\n  float rt = fract(smoothstep(split, 1., t));\n  float rm = smoothstep(split, split + 0.02, t);\n  t = rt;\n  vec2 sp = mix(uv - vec2(0.0, 0.5), uv, pt);\n  float c = 0.008 / length(sp) * pt * mix(1.0, 0.3, pt);\n  m += c;\n  for(float i = 0.; i < 60.; i += 1.){\n    float d = length(uv - t * (Hash12(i) - 0.5));\n    float bright = mix(maxBright, minBright, smoothstep(0.01, 0.02, t));\n    bright *= sin(t * 20. + i) * 0.5 + 0.5;\n    bright *= smoothstep(1.0, 0.8, t);\n    bright *= rm;\n    m += bright / d;\n  }\n  return m;\n}\nvoid main () {\n  vec4 o = vec4(0, 0, 0, 1);\n  #if USE_TEXTURE\n  vec4 texture_tmp = texture2D(texture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n  #endif\n  vec2 uv = vec2((v_uv0.x - 0.5) * wh_ratio, v_uv0.y - 0.5);\n  for(float i = 0.; i < 1.; i += 1.){\n    float t = cc_time.x * 0.5 + i / 3.;\n    float frt = fract(t);\n    float flt = floor(t);\n    vec3 color = sin(5.0 * vec3(0.345, 0.567, 0.753) * flt) * 0.25 + 0.75;\n    float m = Explosion(uv - (Hash12(i + flt) - 0.5), frt);\n    o.rgb += color * m;\n  }\n  #if USE_BGRA\n    gl_FragColor = o.bgra;\n  #else\n    gl_FragColor = o.rgba;\n  #endif\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform ARGS{\n  float wh_ratio;\n};\nvec2 Hash12(float t) {\n  float a = fract(sin(t * 123.45 + 678.9) * 345.124);\n  float b = fract(cos((t + a) * 243.45 + 738.9) * 512.352);\n  return vec2(a, b);\n}\nfloat Explosion(vec2 uv, float t) {\n  float m = 0.0;\n  float minBright = 0.001;\n  float maxBright = 0.002;\n  float split = 0.2;\n  float pt = fract(smoothstep(0., split, t));\n  pt = max(0., log(pt + 0.01) * 0.3 + 1.0);\n  float rt = fract(smoothstep(split, 1., t));\n  float rm = smoothstep(split, split + 0.02, t);\n  t = rt;\n  vec2 sp = mix(uv - vec2(0.0, 0.5), uv, pt);\n  float c = 0.008 / length(sp) * pt * mix(1.0, 0.3, pt);\n  m += c;\n  for(float i = 0.; i < 60.; i += 1.){\n    float d = length(uv - t * (Hash12(i) - 0.5));\n    float bright = mix(maxBright, minBright, smoothstep(0.01, 0.02, t));\n    bright *= sin(t * 20. + i) * 0.5 + 0.5;\n    bright *= smoothstep(1.0, 0.8, t);\n    bright *= rm;\n    m += bright / d;\n  }\n  return m;\n}\nvoid main () {\n  vec4 o = vec4(0, 0, 0, 1);\n  #if USE_TEXTURE\n  vec4 texture_tmp = texture(texture, v_uv0);\n  #if CC_USE_ALPHA_ATLAS_texture\n      texture_tmp.a *= texture(texture, v_uv0 + vec2(0, 0.5)).r;\n  #endif\n  #if INPUT_IS_GAMMA\n    o.rgb *= (texture_tmp.rgb * texture_tmp.rgb);\n    o.a *= texture_tmp.a;\n  #else\n    o *= texture_tmp;\n  #endif\n  #endif\n  vec2 uv = vec2((v_uv0.x - 0.5) * wh_ratio, v_uv0.y - 0.5);\n  for(float i = 0.; i < 1.; i += 1.){\n    float t = cc_time.x * 0.5 + i / 3.;\n    float frt = fract(t);\n    float flt = floor(t);\n    vec3 color = sin(5.0 * vec3(0.345, 0.567, 0.753) * flt) * 0.25 + 0.75;\n    float m = Explosion(uv - (Hash12(i + flt) - 0.5), frt);\n    o.rgb += color * m;\n  }\n  #if USE_BGRA\n    gl_FragColor = o.bgra;\n  #else\n    gl_FragColor = o.rgba;\n  #endif\n}"
      }
    }
  ],
  "subMetas": {}
}